\chapter{Аналитический раздел}

В данном разделе представлено описание языка SQL, различий диалектов PostgreSQL и MySQL, описание реализуемых анализаторов и логики, используемой в SQL.

\section{Обзор языка SQL}
SQL -- это декларативный язык программирования, применяемый для создания, модификации и управления данными в РСУБД. Декларативные выражения представляют собой запросы, описание того, что хочет получить пользователь.

Можно сказать, что язык SQL -- это инструмент, с помощью которого человек управляет базой данных. Сам язык SQL состоит из операторов, инструкций и вычисляемых функций. Операторы можно разделить на следующие четыре группы.

\begin{enumerate}
	\item Операторы определения данных (Data Definition Language, DDL).
	\item Операторы манипуляции данными (Data Manipulation Language, DML).
	\item Операторы определения доступа (Data Control Language, DCL).
	\item Операторы управления транзакциями (Transaction Control Language, TCL).
\end{enumerate}

Группы операторов DDL, DCL, TCL напрямую не работают с данных, поэтому такие операторы не будут рассматриваться подробно в данной курсовой работе.

Группа операторов манипуляции данными включает в себя четыре основных оператора:
\begin{enumerate}
	\item SELECT (будет рассмотрен более подробно) выбирает данные, удовлетворяющие заданными условиям.
	\item INSERT добавляет новые данные.
	\item UPDATE изменяет существующие данные.
	\item DELETE удаляет данные.
\end{enumerate}

\section{Различия в диалектах SQL СУБД \newline MySQL и PostgreSQL}
Чтобы лучше понимать исследуемую область, следует выявить особенности, которые есть в MySQL \cite{mysql-standard}, но нет в PostgreSQL \cite{postgresql-standard}.

Функциональные различия приведены в таблице \ref{diff_tbl}. 

\begin{table}[!h]
	\begin{center}
		\captionsetup{justification=raggedleft,singlelinecheck=off}
		\caption{\label{diff_tbl}Функциональные различия СУБД} 
		\begin{tabular}[c]{|c|c|c|}
			\hline
			\textbf{Особенности} & \textbf{PostgreSQL} & \textbf{MySQL} \\
			\hline
			\specialcell{ANSI SQL \\совместимость} & \specialcell{Близка к стандарту \\ANSI SQL} & \specialcell{Следует некоторым \\ стандартам ANSI SQL} \\
			\hline
			Вложенные SELECT & Да & Нет \\
			\hline
			Транзакации & Да & \specialcell{Да, однако должен \\ использоваться тип \\ таблицы InnoDB} \\
			\hline
			\specialcell{Поддержка внешних \\ ключей} & Да &Нет \\
			\hline
			Представления & Да &Нет \\
			\hline
			\specialcell{Хранимые \\ процедуры} & Да &Нет \\
			\hline
			Триггеры & Да &Нет \\
			\hline
			\specialcell{Ограничители \\ целостности} & Да &Нет \\
			\hline
			\specialcell{Различные типы \\таблиц} & Нет & Да \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Стоит отметить, некоторые синтаксические отличия данных СУБД.

\begin{itemize}
	\item PostgreSQL чувствителен к регистру при сравнении строк, MySQL --­ нет.
	\item Имена баз данных, таблиц, полей и столбцов в PostgreSQL не зависят от регистра, если их не создали	с двойными кавычками вокруг имени, в этом случае они чувствительны к регистру,в MySQL имена таблиц могут быть чувствительны	к регистру или нет, в зависимости от
	используемой операционной системы.
	\item MySQL принимает операторы языка C для логики (| -- ИЛИ, \& -- И), SQL требует AND, OR; решение ­ использовать стандартные ключевые слова SQL, обе базы данных могут с ними работать.
\end{itemize}

\section{Тернарная логика}

В СУБД вместо стандартной булевой логики чаще всего используется тернарная логика, которая является расширением булевой логики. 

С точки зрения SQL, результат логического выражения может быть true (ПРАВДА), false (ЛОЖЬ) или unknown (НЕИЗВЕСТНО). С другой стороны есть тип boolean, и у него есть 3 значения: true, false и null. То есть формально unknown -- формат вычисления, а null -- конкретное значение, которое может быть записано в базе данных.

Рассмотрим основные операции в тернарной логике при помощи таблиц истинностей.


Конъюнкция (<<and>>).
\begin{table}[!h]	
	\begin{center}
		\captionsetup{justification=raggedleft,singlelinecheck=off}
		\caption{Конъюнкция (<<and>>)} 
		\begin{tabular}[c]{|c|c|c|c|}
			\hline
			\textbf{and} & \textbf{true} & \textbf{unknown} & \textbf{false}\\
			\hline
			\textbf{true} & true & unknown & false\\
			\hline
			\textbf{unknown} & unknown & unknown & false \\
			\hline
			\textbf{false} & false & false & false \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Дизъюнкция (<<or>>).
\begin{table}[!h]
	\begin{center}
		\captionsetup{justification=raggedleft,singlelinecheck=off}
		\caption{Дизъюнкция (<<or>>)} 
		\begin{tabular}[c]{|c|c|c|c|}
			\hline
			\textbf{or} & \textbf{true} & \textbf{unknown} & \textbf{false}\\
			\hline
			\textbf{true} & true & true & true\\
			\hline
			\textbf{unknown} & true & unknown & unknown \\
			\hline
			\textbf{false} & true & unknown & false \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\newpage


Отрицание (<<not>>).
\begin{table}[!h]
	\begin{center}
		\captionsetup{justification=raggedleft,singlelinecheck=off}
		\caption{Отрицание (<<not>>)} 
		\begin{tabular}[c]{|c|c|c|c|}
			\hline
			& \textbf{true} & \textbf{unknown} & \textbf{false}\\
			\hline
			\textbf{not} & false & unknown & true\\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Сравнение с помощью операнда <<равенство>> (<<=>>).
\begin{table}[!h]
	\begin{center}
		\captionsetup{justification=raggedleft,singlelinecheck=off}
		\caption{Сравнение с помощью операнда <<равенство>> (<<=>>)} 
		\begin{tabular}[c]{|c|c|c|c|}
			\hline
			= & \textbf{true} & \textbf{unknown} & \textbf{false}\\
			\hline
			\textbf{true} & true & unknown & false\\
			\hline
			\textbf{unknown} & unknown & unknown & unknown \\
			\hline
			\textbf{false} & false & unknown & false \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Сравнение с помощью операнда <<is>>.
\begin{table}[!h]
	\begin{center}
		\captionsetup{justification=raggedleft,singlelinecheck=off}
		\caption{Сравнение с помощью операнда <<is>>} 
		\begin{tabular}[c]{|c|c|c|c|}
			\hline
			& true\textbf{} & \textbf{unknown} & \textbf{false}\\
			\hline
			\textbf{is true} & true & false & false\\
			\hline
			\textbf{is unknown} & false & true & false \\
			\hline
			\textbf{is false} & false & false & true \\
			\hline
			\textbf{is not true} & false & true & true \\
			\hline
			\textbf{is not unknown} & true & false & true \\
			\hline
			\textbf{is not false} & true & true & false \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\section{Оператор SELECT и табличные выражения}

Оператор SELECT -- оператор языка SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному условию. Он позволяет производить выборки данных из одной или нескольких таблиц базы данных и преобразовывать к нужному виду полученные результаты. Этот оператор способен выполнять действия, эквивалентные операторам реляционной алгебры. 

Оператор SELECT состоит из нескольких разделов.
\begin{enumerate}
	\item Список возвращаемых столбцов (существующих в таблицах или вычисляемых на их основе с помощью различных функций).
	\item Табличное выражение определяющие базовый набор данных.
	\item Ограничение на строки из табличного выражения.
	\item Объединение (группировка) строк с помощью правил.
	\item Ограничения на сгруппированные строки. 
	\item Сортировка результирующей выборки.
\end{enumerate}

В качестве табличного представления может выступать таблица из базы данных -- тривиальные табличные выражения, но в более сложных выражениях такие таблицы можно преобразовывать и комбинировать самыми разными способами, например с помощью оператора JOIN можно соединить две и более таблицы (реальные или производные от них) в соответствии с правилами соединения.


В рамках данной работы будет рассматриваться соединение только двух таблиц (оператор JOIN, в рамках данной работы рассматривается INNER JOIN44).

Оператор JOIN -- оператор языка SQL, который формирует результирующую таблицу по заданным условиям, из одной или нескольких уже существующих таблиц SQL. 

Существуют несколько следующих типов JOIN.

\begin{enumerate}
	\item INNER JOIN (или просто JOIN) -- каждая строка из первой (левой) таблицы, сопоставляется с каждой строкой из второй (правой) таблицы, после чего, происходит проверка условия. 
	\item LEFT JOIN -- важен порядок следования таблиц. Сначала происходит формирование таблицы соединением INNER JOIN. Затем, в результат добавляются записи левой таблицы, не вошедшие в результат после INNER JOIN. 
	\item RIGHT JOIN -- важен порядок следования таблиц. Аналогично LEFT JOIN, но во главе вторая таблица. Сначала происходит формирование таблицы соединением INNER JOIN.
	\item FULL JOIN -- оператор FULL JOIN можно воспринимать как сочетание операторов INNER JOIN + LEFT JOIN + RIGHT JOIN. Сначала происходит формирование таблицы соединением \newline INNER JOIN. Затем, в результат добавляются записи левой и правой таблиц, не вошедшие в результат INNER JOIN.
	\item CROSS JOIN (декартово произведение) -- каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы.  
\end{enumerate}

\section{Оператор WHERE}

Для эффективного использования ресурсов компьютера необходимо запрашивать из внешних источников только те данные, которые непосредственно участвуют в построении выборки. Другими словами, нет необходимости запрашивать колонки, которые не задействуются в выводе, также нет необходимости запрашивать данные, которые в последствие будут отфильтрованы.

Оператор WHERE задает ограничения на входную выборку. Все логические условия, которые участвуют в операторе WHERE можно разделить на три группы:
\begin{itemize}
	\item условия, не использующие информацию из таблицы, то есть константы;
	\item условия, использующие данные из одной таблицы;
	\item условия, использующие данные из нескольких таблиц.
\end{itemize}

Наибольший интерес в операторе WHERE представляет группа условий, использующие только одну таблицу, так как такие условия можно применить на этапе запроса данных, таким образом уменьшается объем передаваемых данных.


\section{Лексический анализатор}

В грамматике SQL можно выделить шесть лексических доменов:
\begin{itemize}
	\item целое число -- ненулевая последовательность цифр, которая не начинается с нуля или ноль;
	\item число с плавающей точкой -- два числа разделенных символом <<.>>;
	\item идентификатор -- непустая последовательность латинских букв, цифр и символов <<\_>>, если идентификатор совпадает с ключевым словом, то его необходимо заключить в одинарные кавычки; 
	\item ключевые слова -- множество зарезервированных слов, обычно указываются в верхнем регистре;
	\item специальные символы представлены в таблице \ref{tbl:specsim}.
	\item пробельные символы -- символы, с помощью которых разделяются компоненты (пробел, табуляция, перевод строки).
\end{itemize}



\begin{table}[!h]
	\begin{center}
		\captionsetup{justification=raggedleft,singlelinecheck=off}
		\caption{Специальные символы грамматики SQL.}
		\label{tbl:specsim}
		\begin{tabular}{|c|c|}
			\hline
			\textbf{Символ} & \textbf{Название (англ.)} \\
			\hline
			>= & Greater than or equals operator \\
			\hline
			<= & Less than or equals operator \\
			\hline
			<> & Not equals operator \\
			\hline
			* & Asterisk \\
			\hline
			, & Comma \\
			\hline
			= & Equals operator \\
			\hline
			> & Greater than operator \\
			\hline
			< & Less than operator \\
			\hline
			( & Left paren \\
			\hline
			)& Right paren \\
			\hline
			- & Minus sign \\
			\hline
			+ & Plus sign \\
			\hline
			. & Period \\
			\hline
			; & Semicolon \\
			\hline
			/ & Solidus \\
			\hline
		\end{tabular}
	\end{center}
	
\end{table}

\newpage

Также стоит отметить, что грамматика SQL не учитывает регистр символов для ключевых слов, поэтому <<$SELECT$>> $==$ <<$select$>> (далее ключевые слова будут указываться в верхнем регистре). 

Можно выделить основных 22 ключевых слова, представленных на листинге \ref{lst:keyword}.

\begin{lstlisting}[label=lst:keyword,caption=Основные ключевые слова языка SQL]
AND; AS; CROSS; DISTINCT; FALSE; FROM; GROUP BY; HAVING; INNER; IS; JOIN; 
LEFT; NOT; NULL; ON; OR; ORDER BY; OUTER; RIGHT; SELECT; TRUE; WHERE
\end{lstlisting}

\section{Синтаксический анализатор}

В данной работе будет использоваться только оператор выборки данных -- SELECT, поэтому нет необходимости реализовывать полную поддержку грамматики SQL (в данной работе рассматривался стандарт SQL:1999).

В приложении А представлен диалект грамматики SQL, в формате расширенной формы Бэкуса-Наура\footnote{Формы Бэкуса-Наура -- подход к описанию синтаксических конструкций, при котором одни фрагменты выражения определяются через другие \cite{rfbn}.}(РФБН).



Один из отличий грамматики SQL:1999 от той, которую необходимо будет реализовать и использовать, это возможность использования расширенного имени для таблицы. 

В стандарте SQL:1999 полное имя таблицы формируется из трех частей: имя базы данных, имя схемы и имя таблицы внутри заданной схемы. Так как данное приложение позволяет работать с множеством различных СУБД, то в полном имени таблицы должен упоминаться уникальный идентификатор СУБД, поэтому в используемой грамматике полное имя таблицы формируется из четырех частей: имя СУБД, имя базы данных, имя схемы и имя таблицы внутри заданной схемы.

%Для удобства дальнейшей работы, все названия таблицы будут переводиться 

\section{Семантический анализатор}

Работа семантического анализатора начинается в том случае, если не было ошибок в работе лексического и синтаксического анализатора.

На стадии семантического анализа запроса производится проверка всех введенных значений.
\begin{enumerate}
	\item Производится проверка существования таблиц, а также собирается информация о существующих колонках в данной таблице.
	\item Производится проверка условия для JOIN, а именно проверка существования колонок, используемых в логических условиях.
	\item Проверка списка запрашиваемых колонок, как существующих, так и генерируемых на основе существующих. 
	\item Проверка логического условия WHERE (на этом этапе так же, как и на этапе проверки условий для JOIN, производится проверка на существование колонок).
\end{enumerate}




\section{Вывод}

В данном разделе был проведен обзор языка SQL, анализ различий диалектов PostgreSQL и MySQL, представлено описание лексического, синтаксического и семантического анализаторов, а также разобрана тернарная логика, используемая в SQL.
